use serde::{Deserialize, Serialize};
use serde_json::{Map, Value};

use crate::message::params_log_position::LogPosition;
use crate::message::timestamp::TimeStamp;

use super::*;

#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
#[serde(tag = "jsonrpc")]
pub(crate) enum JsonRpc {
    #[serde(rename = "2.0")]
    JsonRpc2 {
        #[serde(flatten)]
        message: Message,

        #[serde(skip_serializing_if = "Option::is_none")]
        ts: Option<TimeStamp>,
    },
}

/// All [icinga2 messages](https://icinga.com/docs/icinga-2/latest/doc/19-technical-concepts/#json-rpc-message-api)
/// currently supported. This Type represents the method of the JSON-RPC Message and the tuple
/// parameter contains the `params` of the message. Messages that are implemented and ready for
/// use have a struct as a parameter to ensure valid serialization and deserialization. If a
/// messages can be received but the handling is not yet implemented it has a
/// [serde_json::Map<String, Value>](serde_json::Map) as a parameter as an easy way to ensure the
/// deserialization always succeed, without having any limitation on the contained keys and values.
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
#[serde(tag = "method", content = "params")]
pub enum Message {
    /// The `icinga::Hello` message is sent once, as the first message of the connection to establish
    /// a JSON-RPC connection. Since both the Http and JSON-RPC are accepted over the same port.
    /// This tells the endpoint which protocol we are using
    #[serde(rename = "icinga::Hello")]
    Hello(EmptyParams),

    /// The `icinga::Heartbeat` message is sent once every 20 seconds to keep the connection alive and
    /// avoid stale connections. If the master node doesn't receive a message for more than one minute,
    /// it will close the connection.
    #[serde(rename = "event::Heartbeat")]
    HeartBeats(EmptyParams),

    /// An `event::CheckResult` message is used to send CheckResults between the Endpoints. Such a
    /// message has always a host as a parameter, on which the check was performed. If the check was
    /// for a service, the service is also in the parameters. Lastly the params contain a serialized
    /// CheckResult in the Json format.
    #[serde(rename = "event::CheckResult")]
    CheckResult(CheckResultParams),

    /// The `config::Update` message is sent once at the very beginning of the connection by the
    /// master node to synchronize the configuration files.
    #[serde(rename = "config::Update")]
    ConfigUpdate(Map<String, Value>),

    /// The `config::UpdateObject` message is sent for each known object of the master to
    /// synchronize with the endpoint at the beginning of the connection, after the `config::Update`
    /// and before any other message. After that initial synchronization phase, it is sent, whenever
    /// a new object is added to the cluster.
    ///
    /// If the master accepts configurations, this can also be used to create new objects.
    #[serde(rename = "config::UpdateObject")]
    UpdateObject(UpdateObjectParams),

    /// The `config::DeleteObject` message informs the endpoint that a object has been deleted and
    /// does therefore no longer exist
    #[serde(rename = "config::DeleteObject")]
    DeleteObject(Map<String, Value>),

    /// The `pki::RequestCertificate` message allows the endpoint to request a new certificate with
    /// the pki ticket generated by the master. This is used by the `icinga node wizard` command and
    /// can probably be used to ease the installation by the end user, by only requiring them to
    /// provide the ticket.
    #[serde(rename = "pki::RequestCertificate")]
    RequestCertificate(Map<String, Value>),

    /// If the client requesting a certificate with the `pki::RequestCertificate` does not already
    /// have a valid certificate, the master node will respond with a `pki::UpdateCertificate`
    /// message, which contains the public CA of the master, as well as a certificate which was
    /// signed by the master.
    #[serde(rename = "pki::UpdateCertificate")]
    UpdateCertificate(Map<String, Value>),

    /// The `log::SetLogPosition` message is a response to a `event::CheckResult` message, which had
    /// provided a timestamp _"ts"_ alongside the methode name and the params in the JSON-RPC body. It
    /// confirms that the master node has successfully received the message.
    #[serde(rename = "log::SetLogPosition")]
    SetLogPosition(LogPosition),

    #[serde(rename = "event::SetNextCheck")]
    SetNextCheck(Map<String, Value>),

    #[serde(rename = "event::SetLastCheckStarted")]
    SetLastCheckStarted(Map<String, Value>),

    #[serde(rename = "event::SetSuppressedNotifications")]
    SetSuppressedNotifications(Map<String, Value>),

    #[serde(rename = "event::SetSuppressedNotificationTypes")]
    SetSuppressedNotificationTypes(Map<String, Value>),

    #[serde(rename = "event::SetNextNotification")]
    SetNextNotification(Map<String, Value>),

    #[serde(rename = "event::SetForceNextCheck")]
    SetForceNextCheck(Map<String, Value>),

    #[serde(rename = "event::SetForceNextNotification")]
    SetForceNextNotification(Map<String, Value>),

    #[serde(rename = "event::SetAcknowledgement")]
    SetAcknowledgement(Map<String, Value>),

    #[serde(rename = "event::ClearAcknowledgement")]
    ClearAcknowledgement(Map<String, Value>),

    #[serde(rename = "event::SendNotifications")]
    SendNotifications(Map<String, Value>),

    #[serde(rename = "event::NotificationSentUser")]
    NotificationSentUser(Map<String, Value>),

    #[serde(rename = "event::NotificationSentToAllUsers")]
    NotificationSentToAllUsers(Map<String, Value>),

    #[serde(rename = "event::ExecuteCommand")]
    ExecuteCommand(Map<String, Value>),

    #[serde(rename = "event::UpdateExecutions")]
    UpdateExecutions(Map<String, Value>),

    #[serde(rename = "event::ExecutedCommand")]
    ExecutedCommand(Map<String, Value>),
}

impl From<Message> for JsonRpc {
    fn from(msg: Message) -> Self {
        match &msg {
            Message::CheckResult(_) => JsonRpc::JsonRpc2 {
                message: msg,
                ts: Some(Default::default()),
            },
            _ => JsonRpc::JsonRpc2 {
                message: msg,
                ts: None,
            },
        }
    }
}

/// An empty struct is an easy way to force [serde_json](serde_json) to serialize an json object,
/// which can be guaranteed to be always empty, but still present in the message to abide to the
/// JSON-RPC Specification.
#[derive(Serialize, Deserialize, Debug, Eq, PartialEq, Clone)]
pub struct EmptyParams {}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn should_serialize_to_icinga_hello() {
        let obj = JsonRpc::JsonRpc2 {
            message: Message::Hello(EmptyParams {}),
            ts: None,
        };
        let expected = r#"{"jsonrpc":"2.0","method":"icinga::Hello","params":{}}"#;
        let result = serde_json::to_string(&obj).unwrap();
        assert_eq!(expected, result);
    }

    #[test]
    fn should_deserialize_icinga_hello() {
        let msg = r#"{"jsonrpc":"2.0","method":"icinga::Hello","params":{}}"#;
        let expected = JsonRpc::JsonRpc2 {
            message: Message::Hello(EmptyParams {}),
            ts: None,
        };
        let result = serde_json::from_str::<JsonRpc>(msg).unwrap();
        assert_eq!(expected, result);
    }

    #[test]
    fn should_serialize_with_ts() {
        let obj = JsonRpc::JsonRpc2 {
            message: Message::Hello(EmptyParams {}),
            ts: Some(0.0.into()),
        };
        let expected = r#"{"jsonrpc":"2.0","method":"icinga::Hello","params":{},"ts":0.0}"#;
        let result = serde_json::to_string(&obj).unwrap();
        assert_eq!(expected, result);
    }

    #[test]
    fn should_deserialize_with_ts() {
        let msg = r#"{"jsonrpc":"2.0","method":"icinga::Hello","params":{},"ts":0.0}"#;
        let expected = JsonRpc::JsonRpc2 {
            message: Message::Hello(EmptyParams {}),
            ts: Some(0.0.into()),
        };
        let result: JsonRpc = serde_json::from_str(msg).unwrap();
        assert_eq!(expected, result);
    }
}
